My Notes on Loops and Logic
Range is "Up To, But Not Including": 
When I write range(0, 11), I remember it stops at 10. 
If I need to include 10, I always go one number higher.

The Power of f-strings: 
For the multiplication table (Exercise 5), I use f"{i} x {i}"
 because it’s much cleaner and faster than old-school string 
 concatenation.

Modulo is my best friend: 
I use the % operator to check for even or odd numbers. 
If number % 2 == 0, I know it's even; if there's a remainder of 1,
 it's odd.

Think in Rows and Columns: 
For the 8x8 grid, I use nested loops. 
I think of the outer loop as the "row" and the inner loop as the 
"column" moving across that row.

Avoid Infinite Loops: 
When using while, I always double-check that my counter 
(like count += 1) is actually moving toward the exit 
condition so my program doesn't hang.

My Notes on Writing Functions
Return vs. Print: I make sure my functions return values instead 
of just printing them. This makes the function reusable because 
I can save the result to a variable later.

Flexibility with *args: When I don't know how many numbers 
someone will throw at me (like in add_all_nums), I use *args. 
It bundles everything into a tuple so I can loop through it.

Type Checking for Safety: In Exercise 3, I use isinstance() to 
check if the input is a number. It’s better to give a "reasonable
 feedback" message than to let the program crash with a TypeError.

Logic in reverse_list: Instead of using Python’s built-in .
reverse(), I build a new list by iterating backward from len(arr)- 1
 down to 0. It’s a great way to practice index math.

Case Sensitivity: For the check_season function, I always use .
lower() on the input string. That way, if a user types "MARCH"
 or "march," my code still works perfectly.

Data Handling & Best Practices
List Mutations: When I use .append() or .remove(), I remember 
that these change the list in place.

The "Land" Search: When I'm looking for specific words in a
 list (like "land" in countries), I use the in operator 
 (e.g., if "land" in country:). It's super readable and efficient.


Clean Variables: I try to name my variables clearly. 
Instead of x and y, I use even_sum or temp_celsius so anyone 
reading my code knows exactly what’s happening.

How I Visualize the 8x8 Grid
When I wrote the code for the # # # grid, here is exactly what
 was happening in my head:

The Outer Loop (The "Row" Builder): This starts at row 0. 
It stays on row 0 and waits.

The Inner Loop (The "Column" Builder): While the outer loop 
is stuck on row 0, the inner loop runs 8 times, printing a #
 and a space each time.

The Break: Once the inner loop finishes its 8th symbol, 
it dies. The outer loop then hits that print() statement 
(the empty one), which acts like hitting "Enter" on a keyboard 
to move to a new line.

The Repeat: The outer loop moves to row 1, and the
 whole process starts over!

A Quick Trace of the Logic
If we were doing a tiny 2x2 grid, it would look like this
 step-by-step:

Outer Loop (i = 0):

Inner Loop (j = 0): Prints #

Inner Loop (j = 1): Prints #

Inner finishes.

print() moves us to the next line.

Outer Loop (i = 1):

Inner Loop (j = 0): Prints #

Inner Loop (j = 1): Prints #

Inner finishes.

print() moves us to the next line.

My Pro-Tip for Nested Loops
The most common mistake I see (and one I've made plenty of times!)
is forgetting that extra print statement at the end of the outer loop.
 Without it, your computer will just print 64 hashtags in one long, messy 
 line! That empty print() is the secret sauce that gives the grid its shape.