My Key Takeaways & Notes
-Module Imports: I have to remember that import random (and string) must be at the top of every file where I use them; Python doesn't share imports across different tabs automatically.

-The .copy() Method: When I want to shuffle a list without destroying the original order of the input, I need to use list.copy(). If I don't, random.shuffle() will change the original list forever!

-String Joining: To turn a list of random characters into a single string (like for Hex codes or IDs), I use "".join(). It's way more efficient than adding strings together in a loop.

-List Comprehensions: These are like "for loops in a single line." They are perfect for tasks like list_of_rgb_colors because they make the code much cleaner and easier to read.

-Random Sampling: For the "unique numbers" task, random.sample() is my best friend. It's built specifically to pick items without repeating them, which is much easier than writing a loop with "if" statements.

# Mistakes I Made & How I Fixed Them
-The "Undefined Name" Error: I noticed red squiggles under random. I fixed this by adding import random at the top of my script.

-The Missing Parentheses: In my shuffle function, I wrote .cop or .copy. I realized that copy is a method, so I added the parentheses () to actually execute the action.

-Cut-off Logic: In my Hex color function, I started the join() but didn't finish the loop inside it. I fixed this by adding (random.choice(hex_chars) for _ in range(6)) inside the parentheses.

-Naming Conflicts: I originally used type as a variable name in my generate_colors function. Since type() is a built-in Python tool, I changed my variable name to color_type to avoid confusing the computer.

-Scope Issues: I tried to call rgb_color_gen() in practice2.py while it was defined in a different file. I fixed this by making sure all related functions were in the same file so they could "see" each other.

# Mistakes I Made & How I Fixed Them

-The Nesting Nightmare: At first, I tried to put the loops in the wrong order. I realized that the "outer" list must come first in the comprehension syntax, just like a standard nested loop.

-Index Errors: I forgot that the countries were inside a tuple, inside a list, inside another list. I had to add that extra for sub in countries loop to "drill down" to the actual data.

-Hard-coding: I initially thought about typing out the 3-letter country codes (like 'FIN'), but then I realized I could just use string slicing c[0][:3].upper() to do it automatically for any country!